{'text': "modern software regularly interacts with an api a database or a file that means there's a lot of waiting and you need to make sure that your software handles that efficiently if you don't your application is going to be much slower and the more data you process the more you interact with apis the worse this is going to get the way to fix this is to rely on concurrency in python you use the async io package for that i'll give you a brief overview of how the package works but then i'd like to go a bit deeper and also show you how to turn a regular blocking function into something you can run concurrently which could make your program a lot more efficient i don't even have to modify the original function for this it's really easy i'll also talk about how concurrency affects your software design and architecture so make sure to watch this video till the end if you want to learn more about how to design a piece of software from scratch i have a free guide for you you can get this at ironcodes.com design guide contains the seven steps i take when i design new software hopefully it helps you avoid some of the mistakes i made in the past ironcodes.com design guide and the link is also in the description of this video you may have heard the terms concurrent and parallel computing before but what's the difference true parallel computing means that an application runs multiple tasks at the same time where each task runs on a separate processing unit concurrency means that an application is making progress on more than one task at the same time but may switch between these tasks instead of actually running them in parallel if an application works say on tasks a and b it doesn't have to finish a before starting b it can do a little bit of a then switch to doing a little bit of b back again to a and so on this answer on stack overflow nicely illustrates the difference concurrency is two lines of customers ordering from a single cashier and lines take turns ordering parallelism is two lines of customers ordering from two cashiers each line gets its own this year if you translate this back to computers each cashier is a processing unit a cpu core each customer is a task that the processor needs to take care of modern computers use a combination of parallelism and concurrency your cpu might have two four eight or more cores that can perform tasks in parallel your os will run tens to hundreds of different tasks concurrently a subset of those tasks are actually running in parallel while the os seamlessly switches between the tasks parallelism in python has caveat which is the global interpreter lock anytime you run python code it needs to acquire a lock on the interpreter there are reasons for this that i won't go into in this video but effectively means that python code is single threaded even if you stop multiple threads there are ways around this for example by relying on multiple processes instead of multiple threads or by switching to an interpreter that doesn't have to lock this concerns parallelism though concurrency on the other hand works really well in python especially since version 3.10. why is concurrency a smart way to do computing well it so happens that many tasks involve waiting or applications are waiting for files to be read or written too they're constantly communicating with other services over the internet or they're waiting for you to input your password or click a few buttons to help identify traffic lights and recaptcha i hate those things it considerably speeds things up if a computer can do something else while waiting for that network response or for you to finish cursing about recaptchas in other words concurrency is a crucial mechanism for making our computers work efficiently in this age of connectivity the async io package in python gives you the tools to control how concurrency is handled within your application as i've talked about in a previous video the async and weight syntax is the mechanism to achieve this if you write async in front of a method or function you indicate that it's allowed to run this method or function concurrently a weight gives you control over the order that things are being executed in if you write a weight in front of a concurrent statement this means that the portion written below that statement can only be executed after the concurrent statement has completed being able to do this is important when the next part of your code relies on the result of the previous part and this is often the case you need to wait until you get the data back from the database or you need the confirmation from the api that your user is logged in in order to continue and so on i want to start with a quick recap of how concurrent programming in python works so for this you need to use the async and weight syntax i have a simple example program here that retrieves pokemon names so i'm using a free api here to do this so as you can see here is a synchronous version of that code it's a function get a random pokemon name that picks an id between one and the maximum pokemon id that's available we have the url and we construct it using this pokemon id and then i'm using a function http getsync this function i made myself i'm going to explain later on how this works exactly and then we return the name of the pokemon as a string here we have an asynchronous version which does exactly the same thing but uses http get which is another function that gets data yeah using a get", 'start': '0:0:0', 'end': '0:5:29'}